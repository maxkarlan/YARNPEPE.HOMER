<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streams with Collision Detection</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
        let images = [];
        const transparencyThreshold = 128;
        const numOfStreams = 800;

        function preload() {
            for (let i = 0; i < 5; i++) {
                loadImage(`image${i + 1}.png`, img => {
                    img.resize(img.width * 4, img.height * 4);
                    images.push(img);
                });
            }
        }

function setup() {
    createCanvas(windowWidth, windowHeight);
    background(255);

    const colors = [
        [0, random(64, 128), 0],
        [random(64, 124), random(180, 252), 0],
        [255, 253, 208],
        [145, 56, 49],
        [53, 57, 53]
    ];

    const percentages = [0.5, 0.25, 0.15, 0.05, 0.05];

    streamGroups = [];
    for (let j = 0; j < 5; j++) {
        let streams = [];
        let streamCountForImage = Math.round(numOfStreams * percentages[j]);
        for (let i = 0; i < streamCountForImage; i++) {
            streams.push(new Stream(colors[j], j));
        }
        streamGroups.push(streams);
    }
}

        function draw() {
            background(255);

            for (let streams of streamGroups) {
                for (let s of streams) {
                    s.update();
                    s.display();
                }
            }
        }

        function keyPressed() {
            if (key === '1') {
                for (let streams of streamGroups) {
                    for (let s of streams) {
                        s.changeMode();
                    }
                }
            }
        }


        class Stream {
            constructor(color, assignedImageIdx) {
                this.color = color;
                this.points = [];
                this.noiseOffset = random(1000);
                this.currentAngle = random(TWO_PI);
                this.attractMode = false;
                this.assignedImageIdx = assignedImageIdx;
                this.insideImage = false;
                this.initStream();
              	this.insideImage = false;
            }

            changeMode() {
                this.attractMode = !this.attractMode;
            }

            initStream() {
                let startX = random(width);
                let startY = random(height);

                while (this.isOverAnyImage(createVector(startX, startY))) {
                    startX = random(width);
                    startY = random(height);
                }

                this.points.push(createVector(startX, startY));
            }

            isOutsideAllImages(point) {
                return !this.isOverAnyImage(point);
            }

            isOverAnyImage(point) {
                for (let img of images) {
                    if (this.isOverImage(point, img)) return true;
                }
                return false;
            }

            isOverAssignedImage(point) {
                return this.isOverImage(point, images[this.assignedImageIdx]);
            }

            isOverImage(point, img) {
                let imgX = point.x - (width / 2 - img.width / 2);
                let imgY = point.y - (height / 2 - img.height / 2);
                if (imgX >= 0 && imgX < img.width && imgY >= 0 && imgY < img.height) {
                    let pixelColor = img.get(imgX, imgY);
                    return alpha(pixelColor) > transparencyThreshold;
                }
                return false;
            }

update() {
    let lastPoint = this.points[this.points.length - 1];
    let newPoint;

    if (this.attractMode) {
        if (this.isOutsideAllImages(lastPoint) || this.insideImage || this.isOverAssignedImage(lastPoint)) {
            this.currentAngle = this.calculateAngleTowardsImage(lastPoint, this.assignedImageIdx);
        }
    } else {
        if (this.isOutsideAllImages(lastPoint) || this.insideImage) {
            for (let img of images) {
                newPoint = p5.Vector.fromAngle(this.currentAngle).mult(3).add(lastPoint);
                if (this.isOverImage(newPoint, img)) {
                    this.currentAngle += PI;
                    break;
                }
            }
        }
    }

    let angleVariation = map(noise(this.noiseOffset), 0, 1, -PI / 4, PI / 4);
    this.currentAngle += angleVariation;

    newPoint = p5.Vector.fromAngle(this.currentAngle).mult(3).add(lastPoint);

    // If in attractMode and inside assigned image, check if the new point is outside
    if (this.attractMode && this.insideImage && !this.isOverAssignedImage(newPoint)) {
        this.currentAngle += PI; // Flip direction
        newPoint = p5.Vector.fromAngle(this.currentAngle).mult(3).add(lastPoint);
    }

    this.points.push(newPoint);
    this.noiseOffset += 0.1;

    if (this.points.length > 100) {
        this.points.shift();
    }

    // Update the insideImage flag based on the last point
    this.insideImage = this.isOverAssignedImage(lastPoint);
}

calculateAngleTowardsImage(point, imgIdx) {
    if (this.insideImage) {
        return random(TWO_PI);
    }
    let imgCenter = createVector(width / 2, height / 2);
    let angleTowardsImage = p5.Vector.sub(imgCenter, point).heading();
    return angleTowardsImage;
}

            display() {
                noFill();
                stroke(this.color);
                strokeWeight(1);
                beginShape();
                for (let pt of this.points) {
                    vertex(pt.x, pt.y)
                }
                endShape();
            }
        }
    </script>
</body>

</html>